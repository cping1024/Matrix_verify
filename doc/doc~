1 180 float 特征比对
2 提供入库接口（均匀分发到各个硬件设备上）（库id + name）
3 提供基于特定库的比对接口
4 提供全部特征库比对接口
5 返回库id + name + 人id + 人特征编号 （信息保存于cpu）提供map, 特征序号<-->库标记, score
6 要求库容量 < 可用存储大小
7 返回匹配量 < 100
8 提供cpu/gpu version (cpu version use openmp)
9 各特征库要求保证连续性存储，每个库以256为最小单位开空间，每个线程完成一次比对，每个block完成一个最小库单元比对？
  特征向量是否可以基于256转置保存？方便block多thread连续数据载入（block globalMemory --> shareMemory）
10 shareMemory用于vector的存储（256个线程perBlock）
11 结果存于shareMemory,包括分数和id号，每完成一次小库之后，block负责小归约，返回前100名结果（分数+id）
12 最后完成全部小结果归约
13 所有GPU同步后归约结果
14 如果一个库的容量小于65535,则使用cpu完成相关操作，否则将特征上传到gpu,使用gpu计算（保证小库的更快反馈）


14 先实现最基本的功能，之后再慢慢添加其它方案，提升速度
15 数据结构（2 × 100 + 256 × 160 floats）,其中2 × 100表示前100名id与分数，256 × 100分别表示256个特征向量

16 关于多卡多库之间的加库均衡问题（1.1 希望填满已存在的block，1.2 然后在下一个卡上开新的block）
17 在多个block之间采用multiStream方案

version 1.0 仅提供最简单的实现方案，每次请求都对所有库进行比对，排序，然后提取特定库的前100名到cpu，使用cublas + trust技术（每个库都提交前100名）
version 2.0 基于库分组，最小单元数据块存储，实现指定库的特定查找，是否使用如上所述9, 10等优化策略






18 压力测试2： 初始化库之后，对500万特征轮流比对，不再多次初始化库
